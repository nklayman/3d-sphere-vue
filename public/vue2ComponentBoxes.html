<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>3D Sphere Vue 2 (component for each cube)</title>
  </head>
  <body>
    <div id="app"></div>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script type="module">
      import { WebGlHelper } from './WebGl.js'
      // Helper functions
      const avg = arr => arr.reduce((total, num) => total + num, 0) / arr.length
      const random = () => Math.random() * 360
      const getRotations = (num = 20) =>
        Array(num)
          .map(() => [random(), random(), random()])
          .fill()
      const geometry = new THREE.BoxGeometry(2, 2, 2)
      const material = new THREE.MeshNormalMaterial()

      // Setup three scene
      const scene = new THREE.Scene()
      const light = new THREE.DirectionalLight(0xffffff, 1)
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      )
      camera.position.set(0, 0, 3.2)
      light.position.set(-5, 0, -10).normalize()
      scene.add(light)

      const renderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: false
      })
      renderer.setSize(window.innerWidth, window.innerHeight)

      // Component renders nothing, but controls a cube in scene
      const Box = Vue.component('Box', {
        name: 'Box',
        template: `<div></div>`,
        data() {
          return {
            mesh: undefined
          }
        },
        props: {
          rotation: {
            x: Number,
            y: Number,
            z: Number
          },
          index: Number
        },
        watch: {
          rotation(val) {
            if (this.mesh) {
              this.mesh.rotation.x = val.x
              this.mesh.rotation.y = val.y
              this.mesh.rotation.z = val.z
            }
          }
        },
        mounted() {
          const mesh = new THREE.Mesh(geometry, material)
          mesh.rotation.set(this.rotation.x, this.rotation.y, this.rotation.z)
          mesh.name = 'mesh' + this.index
          scene.add(mesh)
          this.mesh = mesh
        }
      })
      // Contains all the box components, as well as the threejs display
      const BoxContainer = Vue.component('BoxContainer', {
        name: 'BoxContainer',
        data() {
          return {
            boxes: [],
            fps: 0,
            numberOfBoxes: 20
          }
        },
        watch: {
          numberOfBoxes(numberOfBoxes) {
            let diff = this.boxes.length - numberOfBoxes
            let boxesHaveMore = diff > 0
            let boxesHaveLess = diff < 0
            let same = diff === 0

            if (same) return

            if (boxesHaveLess) {
              for (let i = 0; i < 0 - diff; i++) {
                this.boxes.push({
                  x: random(),
                  y: random(),
                  z: random()
                })
              }
              return
            }

            if (boxesHaveMore) {
              for (let i = 0; i < diff; i++) {
                scene.remove(
                  scene.getObjectByName('mesh' + (i + parseInt(numberOfBoxes)))
                )
                let box = this.boxes.pop()
              }
              return
            }
          }
        },
        mounted() {
          // Mount the threejs display
          this.$refs.renderDisplay.appendChild(renderer.domElement)

          // Create initial cubes
          for (let i = 0; i < 20; i++) {
            this.boxes.push({
              x: random(),
              y: random(),
              z: random()
            })
          }

          this.numberOfBoxes = 20

          let last = Date.now()
          let frames = Array(10).fill(0)
          let boundCallback

          function loop() {
            let frame = requestAnimationFrame(boundCallback)

            // Update props for each component so they rerender and update their cube
            for (let i = 0; i < this.boxes.length; i++) {
              Vue.set(this.boxes, i, {
                x: this.boxes[i].x + 0.01,
                y: this.boxes[i].y + 0.01,
                z: this.boxes[i].z + 0.01
              })
            }

            // Update threejs display
            // Each component will have updated the rotation of their cube
            renderer.render(scene, camera)

            const now = Date.now()
            const elapsed = now - last

            frames.shift()
            frames[frames.length] = 1000 / elapsed
            this.fps = Math.round(avg(frames))
            last = now
          }

          boundCallback = loop.bind(this)
          this.frame = requestAnimationFrame(boundCallback)
        },
        template: `<div>FPS: {{fps}}
          <select v-model="numberOfBoxes">
            <option value="20" selected>20</option>
            <option value="100">100</option>
            <option value="200">200</option>
            <option value="500">500</option>
            <option value="1000">1000</option>
            <option value="2000">2000</option>
            <option value="5000">5000</option>
            <option value="10000">10000</option>
          </select>
          <div ref="renderDisplay"></div>
          <Box v-for="(rotation, index) in boxes" :key="index" :index="index" :rotation="rotation"></Box>
        </div>`
      })
      const app = new Vue({
        el: '#app',
        render: h => h('BoxContainer'),
        components: {
          BoxContainer,
          Box
        }
      })
    </script>
  </body>
</html>
